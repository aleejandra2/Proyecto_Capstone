{% load static %}
<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <title>Nivel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      background: #1e1e1e;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      color-scheme: light dark;
    }

    .stage {
      position: fixed;
      left: 0;
      top: 0;
      transform-origin: 0 0;
    }

    canvas {
      position: absolute;
      left: 0;
      top: 0;
      image-rendering: pixelated;
    }

    #bg {
      z-index: 0;
    }

    #game {
      z-index: 1;
    }

    /* Overlay preguntas */
    .ask {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: radial-gradient(80% 80% at 50% 30%,
          rgba(0, 0, 0, .25),
          rgba(0, 0, 0, .8));
      z-index: 9000;
    }

    .ask.show {
      display: flex;
    }

    .ask-card {
      min-width: min(320px, 90vw);
      max-width: min(540px, 92vw);
      background:
        radial-gradient(130% 130% at 0% 0%, #ffffff, #f1f5ff);
      color: #111827;
      border-radius: 24px;
      padding: 18px 20px 16px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, .45);
      font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      border: 2px solid rgba(59, 130, 246, .18);
      position: relative;
      transform: translateY(10px) scale(.94);
      opacity: 0;
      animation: ask-pop .18s ease-out forwards;
    }

    @keyframes ask-pop {
      from {
        opacity: 0;
        transform: translateY(14px) scale(.9);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .ask-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }

    .ask-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 30% 0%, #fef3c7, #facc15);
      box-shadow: 0 4px 10px rgba(251, 191, 36, .6);
      font-weight: 800;
      color: #1f2937;
      font-size: 20px;
    }

    .ask-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .08em;
      font-weight: 700;
      color: #6b7280;
      display: block;
    }

    .ask-card h3 {
      margin: 2px 0 0;
      font-size: 18px;
      font-weight: 700;
      color: #111827;
    }

    .ask-ops,
    .ask-card .ops {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(88px, 1fr));
      gap: 10px;
    }

    .ask-card button {
      padding: 9px 11px;
      border-radius: 999px;
      border: none;
      background: #e5e7eb;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .12);
      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        background .12s ease-out,
        color .12s ease-out;
      white-space: nowrap;
    }

    .ask-card button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, .15);
    }

    .ask-card button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, .12);
    }

    .ask-card button.ok {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #ffffff;
      box-shadow: 0 4px 12px rgba(22, 163, 74, .45);
    }

    .ask-card button.bad {
      background: linear-gradient(135deg, #f97373, #ef4444);
      color: #ffffff;
      box-shadow: 0 4px 12px rgba(248, 113, 113, .45);
    }

    @media (max-width: 480px) {
      .ask-card {
        padding: 16px 14px 14px;
        border-radius: 20px;
      }

      .ask-card h3 {
        font-size: 16px;
      }
    }

    /* Menús */
    .menu {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      z-index: 9500;
      color: #fff;
      background:radial-gradient(80% 80% at 50% 50%, rgba(0, 0, 0, .2), rgba(0, 0, 0, .85)),
    }

    .menu.show {
      display: grid
    }

    .menu-card {
      text-align: center;
      padding: 20px 24px;
      background: rgba(0, 0, 0, .6);
      border: 1px solid rgba(255, 255, 255, .15);
      border-radius: 16px;
      min-width: 280px;
      max-width: 520px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, .5);
      backdrop-filter: blur(4px);
    }

    .menu-card h1 {
      margin: 0 0 10px;
      font-size: 42px;
      letter-spacing: .5px
    }

    .menu-card p {
      margin: 0 0 14px;
      opacity: .9
    }

    .menu-card .btns {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 6px
    }

    .menu-card button {
      cursor: pointer;
      border-radius: 10px;
      border: 1px solid #ffd54a;
      background: #ffd54a;
      color: #111;
      padding: 10px 14px;
      font-weight: 600
    }

    .menu-card button.ghost {
      background: transparent;
      color: #ffd54a
    }

    /* Confeti */
    #fx {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 12000
    }
  </style>

  <!-- Favicon -->
  <link rel="icon" href="{% static 'LevelUp/img/logo.png' %}" type="image/x-icon">
  <link rel="shortcut icon" href="{% static 'LevelUp/img/logo.png' %}" type="image/x-icon">

</head>

<body>
  <!-- Escena -->
  <div class="stage" id="stage">
    <canvas id="bg"></canvas>
    <canvas id="game"></canvas>
  </div>

  <!-- Confeti -->
  <canvas id="fx"></canvas>

  <!-- Menú de inicio -->
  <div id="menuStart" class="menu show">
    <div class="menu-card">
      <h1>¡LevelUp!</h1>
      <p>Responde correcto para derrotar a los enemigos.</p>
      <div class="btns">
        <button id="btnStart">¡Jugar!</button>
      </div>
    </div>
  </div>

  <!-- Menú final -->
  <div id="menuEnd" class="menu">
    <div class="menu-card">
      <h1>¡Completado!</h1>
      <p id="endStats">¡Bien hecho!</p>
      <div class="btns">
        <button id="btnRetry">Reintentar</button>
        {% if actividad %}
          <button id="btnExit" type="button" class="ghost">Salir</button>
        {% endif %}
      </div>
    </div>
  </div>

  <!-- Motor del juego -->
  <script src="{% static 'LevelUp/js/misiones/play.js' %}"></script>

  <script>
    /* ================== CONFIG & UTILS ================== */
    const MAP_URL = "{{ map_url|escapejs }}";
    const MAP_ABS = new URL(MAP_URL, window.location.origin).toString();
    // URL para finalizar el intento del minijuego (item_id = 0)
    const FINISH_URL = {% if actividad %}"{% url 'api_item_answer' actividad.pk 0 %}"{% else %}null{% endif %};

    // Helper para CSRF desde cookie
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== "") {
        const cookies = document.cookie.split(";");
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + "=")) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
    // URL para volver a la lista de actividades del estudiante
    const ACTIVIDADES_URL = "{% url 'estudiante_lista' %}";
    const FLIP_H = 0x80000000, FLIP_V = 0x40000000, FLIP_D = 0x20000000, GID_MASK = 0x1fffffff;
    const absUrl = (rel, base) => new URL(rel, base).href;
    const decodeGid = raw => ({ gid: raw & GID_MASK, flipH: !!(raw & FLIP_H), flipV: !!(raw & FLIP_V), flipD: !!(raw & FLIP_D) });
    const imgCache = new Map();
    function loadImage(src) {
      if (imgCache.has(src)) return imgCache.get(src);
      const p = new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = () => rej(new Error('No se pudo cargar: ' + src)); i.src = src; });
      imgCache.set(src, p); return p;
    }
    const fetchText = async u => { const r = await fetch(u); if (!r.ok) throw new Error('HTTP ' + r.status + ' ' + u); return r.text(); };
    const fetchJSON = async u => { const r = await fetch(u); if (!r.ok) throw new Error('HTTP ' + r.status + ' ' + u); return r.json(); };

    /* ================== CANVAS / ESCALADO =================== */
    const stageEl = document.getElementById('stage');
    const bg = document.getElementById('bg'); const bgCtx = bg.getContext('2d'); bgCtx.imageSmoothingEnabled = false;
    const game = document.getElementById('game');
    function fitStage(pxW, pxH) {
      stageEl.style.width = pxW + 'px'; stageEl.style.height = pxH + 'px';
      const s = Math.min(window.innerWidth / pxW, window.innerHeight / pxH);
      stageEl.style.transform = `scale(${s})`;
      const left = Math.max(0, Math.floor((window.innerWidth - pxW * s) / 2));
      const top = Math.max(0, Math.floor((window.innerHeight - pxH * s) / 2));
      stageEl.style.left = left + 'px'; stageEl.style.top = top + 'px';
    }
    addEventListener('resize', () => { if (window.LEVEL) fitStage(window.LEVEL.size.pxW, window.LEVEL.size.pxH); });

    /* ================== AUDIO UI (start/win) =================== */
    const UIAudio = (() => {
      const Ctx = window.AudioContext || window.webkitAudioContext; let ctx = null;
      const get = () => { if (!Ctx) return null; if (!ctx) ctx = new Ctx(); if (ctx.state === 'suspended') ctx.resume(); return ctx; };
      function play(type = 'start') {
        const ac = get(); if (!ac) return;
        if (type === 'start') {
          const o = ac.createOscillator(), g = ac.createGain(); o.type = 'square'; o.frequency.value = 520; o.connect(g); g.connect(ac.destination);
          g.gain.setValueAtTime(0.0001, ac.currentTime); g.gain.exponentialRampToValueAtTime(0.18, ac.currentTime + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + 0.22); o.start(); o.stop(ac.currentTime + 0.24);
        } else if (type === 'win') {
          [660, 880, 1320].forEach((f, i) => {
            const t = ac.currentTime + i * 0.08; const o = ac.createOscillator(), g = ac.createGain();
            o.type = 'triangle'; o.frequency.value = f; o.connect(g); g.connect(ac.destination);
            g.gain.setValueAtTime(0.0001, t); g.gain.exponentialRampToValueAtTime(0.18, t + 0.02);
            g.gain.exponentialRampToValueAtTime(0.0001, t + 0.22); o.start(t); o.stop(t + 0.24);
          });
        }
      }
      return { play };
    })();

    /* ================== CONFETI =================== */
    const FX = (() => {
      const c = document.getElementById('fx'); const ctx = c.getContext('2d'); let parts = [], raf = null;
      function resize() { c.width = innerWidth; c.height = innerHeight; } addEventListener('resize', resize); resize();
      function spawn(n = 160) {
        for (let i = 0; i < n; i++) {
          parts.push({
            x: Math.random() * innerWidth, y: -20 * Math.random(), vx: (Math.random() * 2 - 1) * 4, vy: 2 + Math.random() * 2, ay: .12, s: 3 + Math.random() * 7,
            r: Math.random() * Math.PI, rv: (Math.random() * 2 - 1) * .25, col: `hsl(${Math.random() * 360},90%,60%)`, life: 0, ttl: 220 + Math.random() * 120
          });
        }
      }
      function tick() {
        ctx.clearRect(0, 0, c.width, c.height);
        for (const p of parts) {
          p.vx *= .995; p.vy += p.ay; p.x += p.vx; p.y += p.vy; p.r += p.rv; p.life++;
          ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.r); ctx.fillStyle = p.col; ctx.fillRect(-p.s / 2, -p.s / 2, p.s, p.s); ctx.restore();
        }
        parts = parts.filter(p => p.y < c.height + 40 && p.life < p.ttl);
        if (parts.length > 0) { raf = requestAnimationFrame(tick); } else { raf = null; ctx.clearRect(0, 0, c.width, c.height); }
      }
      function burst(ms = 2000) { spawn(200); if (!raf) tick(); const t0 = performance.now(); (function drip() { if (performance.now() - t0 < ms) { spawn(25); setTimeout(drip, 100); } })(); }
      return { burst };
    })();

    /* ================== TILESETS + MAPA =================== */
    async function loadTileset(tsRef, baseForJSON) {
      if (!tsRef.source) return null;
      const tsxUrl = absUrl(tsRef.source, baseForJSON);
      const xml = new DOMParser().parseFromString(await fetchText(tsxUrl), 'text/xml');
      const root = xml.querySelector('tileset');
      const tilewidth = +(root.getAttribute('tilewidth') || tsRef.tilewidth || 0);
      const tileheight = +(root.getAttribute('tileheight') || tsRef.tileheight || 0);
      const spacing = +(root.getAttribute('spacing') || 0);
      const margin = +(root.getAttribute('margin') || 0);
      const to = root.querySelector('tileoffset'); const tileOffsetX = +(to?.getAttribute('x') || 0); const tileOffsetY = +(to?.getAttribute('y') || 0);
      const tileRenderSize = (root.getAttribute('tilerendersize') || 'tile').toLowerCase();
      const srcName = (tsRef.source || '').toLowerCase(); const isPlatform = /plataform|plataforma/.test(srcName);

      const solidIds = new Set(); const solidTop = new Map(); const solidBottom = new Map();
      if (isPlatform) {
        root.querySelectorAll(':scope > tile').forEach(t => {
          const id = +(t.getAttribute('id') || 0); const og = t.querySelector('objectgroup'); if (!og) return;
          let minY = Infinity, maxY = -Infinity;
          og.querySelectorAll('object').forEach(o => {
            const oy = +o.getAttribute('y') || 0, w = +o.getAttribute('width') || 0, h = +o.getAttribute('height') || 0;
            const poly = o.querySelector('polygon');
            if (poly) { (poly.getAttribute('points') || '').trim().split(/\s+/).forEach(p => { const [px, py] = p.split(',').map(Number); const yy = oy + py; minY = Math.min(minY, yy); maxY = Math.max(maxY, yy); }); }
            else if (w && h) { minY = Math.min(minY, oy); maxY = Math.max(maxY, oy + h); }
            else { minY = Math.min(minY, oy); maxY = Math.max(maxY, oy); }
          });
          if (isFinite(minY) && isFinite(maxY)) { solidIds.add(id); solidTop.set(id, Math.round(minY)); solidBottom.set(id, Math.round(maxY)); }
        });
      }

      const imageEl = root.querySelector(':scope > image');
      if (imageEl) {
        const imageUrl = absUrl(imageEl.getAttribute('source'), tsxUrl);
        const columns = +(root.getAttribute('columns') || 0);
        const imagewidth = +(imageEl.getAttribute('width') || 0);
        const cols = columns || Math.floor((imagewidth - 2 * margin + spacing) / (tilewidth + spacing)) || 1;
        return {
          kind: 'spritesheet', firstgid: tsRef.firstgid, tilewidth, tileheight, spacing, margin, imageUrl, columns: cols,
          tileOffsetX, tileOffsetY, tileRenderSize, isPlatform, solidIds, solidTop, solidBottom
        };
      } else {
        const tiles = new Map();
        root.querySelectorAll(':scope > tile').forEach(t => {
          const id = +(t.getAttribute('id') || 0), img = t.querySelector('image'); if (!img) return;
          tiles.set(id, { url: absUrl(img.getAttribute('source'), tsxUrl), w: +(img.getAttribute('width') || tilewidth || 0), h: +(img.getAttribute('height') || tileheight || 0) });
        });
        return {
          kind: 'collection', firstgid: tsRef.firstgid, tilewidth, tileheight, tiles,
          tileOffsetX, tileOffsetY, tileRenderSize, isPlatform, solidIds, solidTop, solidBottom
        };
      }
    }
    const getTilesetForGid = (tilesets, gid) => { let f = null; for (const ts of tilesets) { if (gid >= ts.firstgid) f = ts; else break; } return f; };

    async function drawTileFromTileset(ctx, ts, localId, dx, dy, flipH, flipV, flipD, cellW, cellH) {
      if (!ts) return;
      if (ts.kind === 'spritesheet') {
        const img = await loadImage(ts.imageUrl);
        const cols = ts.columns || 1, sxI = localId % cols, syI = Math.floor(localId / cols);
        const sx = (ts.margin || 0) + sxI * (ts.tilewidth + (ts.spacing || 0));
        const sy = (ts.margin || 0) + syI * (ts.tileheight + (ts.spacing || 0));
        const ox = dx + (ts.tileOffsetX || 0), oy = dy + (ts.tileOffsetY || 0);
        ctx.save(); ctx.translate(ox + (flipH ? ts.tilewidth : 0), oy + (flipV ? ts.tileheight : 0));
        if (flipD) { ctx.translate(ts.tilewidth, 0); ctx.rotate(Math.PI / 2);[flipH, flipV] = [flipV, flipH]; }
        ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
        ctx.drawImage(img, sx, sy, ts.tilewidth, ts.tileheight, 0, 0, ts.tilewidth, ts.tileheight);
        ctx.restore();
      } else {
        const t = ts.tiles.get(localId); if (!t) return;
        const img = await loadImage(t.url);
        const useGrid = (ts.tileRenderSize === 'grid'); const destW = useGrid ? ts.tilewidth : img.width; const destH = useGrid ? ts.tileheight : img.height;
        const ox = dx + (ts.tileOffsetX || 0); const oy = dy + (cellH - destH) + (ts.tileOffsetY || 0);
        ctx.save(); let w = destW, h = destH; ctx.translate(ox, oy);
        if (flipD) { ctx.translate(h, 0); ctx.rotate(Math.PI / 2);[w, h] = [h, w];[flipH, flipV] = [flipV, flipH]; }
        ctx.translate(flipH ? w : 0, flipV ? h : 0); ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
        ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, destW, destH);
        ctx.restore();
      }
    }

    (async () => {
      const map = await fetchJSON(MAP_ABS);
      const cellW = map.tilewidth, cellH = map.tileheight;
      const pxW = map.width * cellW, pxH = map.height * cellH;
      bg.width = game.width = pxW; bg.height = game.height = pxH; fitStage(pxW, pxH);

      const tilesets = []; for (const tsRef of map.tilesets) tilesets.push(await loadTileset(tsRef, MAP_ABS));
      tilesets.sort((a, b) => a.firstgid - b.firstgid);

      const solids = Array.from({ length: map.height }, () => Array(map.width).fill(false));
      const fullBlocks = Array.from({ length: map.height }, () => Array(map.width).fill(false));
      const solidTopGrid = Array.from({ length: map.height }, () => Array(map.width).fill(0));
      const solidBottomGrid = Array.from({ length: map.height }, () => Array(map.width).fill(cellH));

      for (const layer of map.layers) {
        if (layer.type !== 'tilelayer' || !layer.visible) continue;
        const w = layer.width, data = layer.data;
        const layerIsSolid = (layer.properties || []).some(p => p.name === 'collision' && p.value === true);
        for (let i = 0; i < data.length; i++) {
          const raw = data[i]; if (!raw) continue;
          const x = i % w, y = Math.floor(i / w);
          if (layerIsSolid) { solids[y][x] = true; fullBlocks[y][x] = true; solidTopGrid[y][x] = 0; solidBottomGrid[y][x] = cellH; continue; }
          const { gid } = decodeGid(raw); const ts = getTilesetForGid(tilesets, gid); if (!ts || !ts.isPlatform) continue;
          const localId = gid - ts.firstgid;
          if (ts.solidIds && ts.solidIds.has(localId)) {
            const sy = (ts.tileheight ? cellH / ts.tileheight : 1), off = ts.tileOffsetY || 0;
            const top = Math.max(0, Math.min(cellH, Math.round((ts.solidTop.get(localId) + off) * sy)));
            const bottom = Math.max(0, Math.min(cellH, Math.round((ts.solidBottom.get(localId) + off) * sy)));
            solids[y][x] = true; fullBlocks[y][x] = false; solidTopGrid[y][x] = top; solidBottomGrid[y][x] = bottom;
          }
        }
      }

      // Entidades + preguntas
      let spawn = null; const coins = []; const enemies = [];

      let questions = Array.isArray(map.questions)
        ? map.questions.map((q, i) => {
            const id = (q && q.id != null) ? q.id : (10000 + i);

            if (Array.isArray(q.questions) && q.questions.length) {
              return { ...q, id };
            }

            // En caso de solo una pregunta
            const opts = Array.isArray(q.options) && q.options.length >= 2
              ? q.options
              : [q.a1, q.a2, q.a3, q.a4].filter(Boolean);

            const corr = Number.isInteger(q.correct)
              ? q.correct
              : Math.max(0, (q.correct || 1) - 1);

            return {
              id,
              q: q.q || q.question || '¿Pregunta?',
              options: opts,
              correct: corr
            };
          })
        : [];

      for (const layer of map.layers) {
        if (layer.type !== 'objectgroup') continue;
        for (const obj of (layer.objects || [])) {
          const t = (obj.type || obj.name || layer?.name || '').trim().toLowerCase();
          const R = obj.gid
            ? {
              x: Math.round(obj.x - (obj.width || map.tilewidth) / 2), y: Math.round(obj.y - (obj.height || map.tileheight)),
              w: Math.round(obj.width || map.tilewidth), h: Math.round(obj.height || map.tileheight), kind: 'tile'
            }
            : (obj.point || (!obj.width && !obj.height))
              ? { x: Math.round(obj.x), y: Math.round(obj.y), w: 0, h: 0, kind: 'point' }
              : { x: Math.round(obj.x), y: Math.round(obj.y), w: Math.round(obj.width || 0), h: Math.round(obj.height || 0), kind: 'rect' };
          const P = {}; (obj.properties || []).forEach(p => P[p.name] = p.value);
          const cx = (R.kind === 'point') ? R.x : (R.x + R.w / 2); const cy = (R.kind === 'point') ? R.y : (R.y + R.h / 2);

          if (t === 'spawn' || t === 'player') spawn = { x: cx, y: cy };
          else if (t === 'coin' || t === 'coins') coins.push({ id: obj.id, x: cx, y: cy });
          else if (t === 'enemy') {
            if (R.kind === 'rect' && R.w > cellW * .8 && R.h < cellH * .6) {
              enemies.push({
                id: obj.id, x: R.x + R.w / 2, y: R.y + R.h, patrolMinX: R.x, patrolMaxX: R.x + R.w,
                speed: +(P.speed ?? 60), dir: (P.dir || 'right'), qid: (P.qid != null ? String(P.qid) : null)
              });
            } else {
              const range = +(P.range ?? 2 * cellW);
              enemies.push({
                id: obj.id, x: cx, y: cy, patrolMinX: cx - range * .5, patrolMaxX: cx + range * .5,
                speed: +(P.speed ?? 60), dir: (P.dir || 'right'), qid: (P.qid != null ? String(P.qid) : null)
              });
            }
          } else if (t === 'question' || t === 'quiz' || t === 'pregunta') {
            const opts = [P.a1, P.a2, P.a3, P.a4].filter(Boolean);
            const corr = Number.isInteger(P.correct) ? P.correct : Math.max(0, (P.correct || 1) - 1);
            questions.push({
              id: obj.id, q: P.q || '¿Pregunta?', options: (opts.length >= 2 ? opts : ['Opción 1', 'Opción 2']),
              correct: Math.min(Math.max(0, corr), Math.max(0, (opts.length - 1)))
            });
          }
        }
      }

      // Pintar fondo
      bgCtx.clearRect(0, 0, bg.width, bg.height);
      for (const layer of map.layers) {
        if (!layer.visible) continue;
        if (layer.type === 'imagelayer' && layer.image) {
          try { const img = await loadImage(absUrl(layer.image, MAP_ABS)); bgCtx.drawImage(img, layer.offsetx || 0, layer.offsety || 0); }
          catch (e) { console.warn('No se pudo cargar imagen de capa:', e.message); }
        }
        if (layer.type === 'tilelayer') {
          const w = layer.width, data = layer.data, lx = layer.offsetx || 0, ly = layer.offsety || 0;
          for (let i = 0; i < data.length; i++) {
            const raw = data[i]; if (!raw) continue;
            const { gid, flipH, flipV, flipD } = decodeGid(raw);
            const ts = getTilesetForGid(tilesets, gid); if (!ts) continue;
            const localId = gid - ts.firstgid;
            const x = lx + (i % w) * cellW; const y = ly + Math.floor(i / w) * cellH;
            await drawTileFromTileset(bgCtx, ts, localId, x, y, flipH, flipV, flipD, cellW, cellH);
          }
        }
      }

      const ASSETS = {
        player: "{% static 'LevelUp/img/misiones/Timo_caminando.png' %}",
        coin: "{% static 'LevelUp/img/misiones/coin.png' %}",
        enemy1: "{% static 'LevelUp/img/misiones/Timo_malvado.png' %}"
      };

      window.LEVEL = {
        mapUrl: MAP_ABS,
        size: { tilesW: map.width, tilesH: map.height, pxW, pxH },
        tileSize: { w: cellW, h: cellH },
        spawn, coins, enemies, questions,
        solids, fullBlocks, solidTopGrid, solidBottomGrid,
        assets: ASSETS,
        settings: { gravity: 0.8, jump: -26, enemyGroundOffsetPx: 0 }
      };

      const menuStart = document.getElementById('menuStart');
      const menuEnd   = document.getElementById('menuEnd');
      const endStats  = document.getElementById('endStats');
      const btnStart  = document.getElementById('btnStart');
      const btnRetry  = document.getElementById('btnRetry');

      let gameStarted = false;

      function startGame() {
        if (gameStarted) return;
        gameStarted = true;

        // ocultar menú de inicio y sonido de comienzo
        menuStart.classList.remove('show');
        UIAudio.play('start');

        // inicia el motor del juego
        window.Play.init(game, window.LEVEL, askQuestion, async (stats) => {
        // 1) Finalizar intento en el backend y saber si aún puede reintentar
        let puedeReintentar = true;

        if (FINISH_URL) {
          try {
            const resp = await fetch(FINISH_URL, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": getCookie("csrftoken"),
              },
              body: JSON.stringify({
                payload: {
                  completado: true,
                  kind: "mission",
                  meta: {
                    coins: stats.coins ?? 0,
                    time:  stats.time  ?? 0,
                    correctas: stats.coins ?? 0,
                    total:     stats.coins ?? 0,
                  },
                },
              }),
            });

            if (resp.ok) {
              const data = await resp.json();
              if (typeof data.puede_reintentar === "boolean") {
                puedeReintentar = data.puede_reintentar;
              }
            }
          } catch (e) {
            console.error("Error finalizando intento del minijuego:", e);
          }
        }

        // 2) Feedback visual y menú final
        UIAudio.play('win');
        FX.burst(2200);
        endStats.textContent =
          `Monedas: ${stats.coins} · Tiempo: ${Math.round(stats.time / 1000)} s`;

        // 3) Configurar botón "Reintentar" según intentos disponibles
        if (btnRetry) {
          if (puedeReintentar) {
            btnRetry.disabled = false;
            btnRetry.classList.remove('ghost');
            btnRetry.onclick = () => location.reload();
          } else {
            btnRetry.disabled = true;
            btnRetry.classList.add('ghost');
            // btnRetry.textContent = "Sin intentos";
          }
        }

        menuEnd.classList.add('show');
      });
      }

      // click en "¡Jugar!"
      if (btnStart) {
        btnStart.addEventListener('click', startGame);
      }

      // botón Reintentar
      //document.getElementById('btnRetry').onclick = () => location.reload();

      // Redirigir a la lista de actividades cuando el alumno pulsa "Salir"
      const btnExit = document.getElementById('btnExit');
      if (btnExit) {
        btnExit.addEventListener('click', () => {
          window.location.href = "{% url 'estudiante_lista' %}";
        });
      }

    })().catch(e => console.error('Fallo general:', e));

    /* ===== Overlay Preguntas ===== */
    const ASK = (() => {
      const wrap = document.createElement('div');
      wrap.className = 'ask';

      // Tarjeta más visual
      wrap.innerHTML = `
        <div class="ask-card">
          <div class="ask-header">
            <div class="ask-icon">?</div>
            <div class="ask-titles">
              <span class="ask-label">Pregunta del villano</span>
              <h3 id="askQ"></h3>
            </div>
          </div>
          <div class="ask-ops" id="askOps"></div>
        </div>
      `;

      document.body.appendChild(wrap);

      function open(q, ops, correctIdx, onOk, onBad) {
        const qEl = document.getElementById('askQ');
        const box = document.getElementById('askOps');
        if (!qEl || !box) return;

        qEl.textContent = q;
        box.innerHTML = '';

        ops.forEach((t, i) => {
          const b = document.createElement('button');
          b.type = 'button';
          b.textContent = t;

          b.addEventListener('click', () => {
            if (i === correctIdx) {
              b.classList.add('ok');
              onOk && onOk();
            } else {
              b.classList.add('bad');
              onBad && onBad();
            }
          });

          box.appendChild(b);
        });

        wrap.classList.add('show');
      }

      function close() {
        wrap.classList.remove('show');
      }

      return { open, close };
    })();
      
        function askQuestion(qid, onEnemyOk, onEnemyBad) {
      const level = window.LEVEL || {};
      const cfg = level.config || {};
      const list = Array.isArray(level.questions) ? level.questions : [];
      const mapping = (cfg.mapping_mode || "id").toLowerCase();

      // 1) buscar el "paquete" base
      let base = null;
      if (mapping === "index") {
        const n = Number(qid);
        if (Number.isFinite(n) && n >= 1 && n <= list.length) base = list[n - 1];
      } else {
        base = list.find(x => String(x?.id) === String(qid)) || null;
        if (!base) {
          const n = Number(qid);
          if (Number.isFinite(n) && n >= 1 && n <= list.length) base = list[n - 1];
        }
      }

      // 2) fallback
      const fallbackPrompt =
        (cfg.fallback_q && String(cfg.fallback_q).trim()) || "¿2 + 2 = ?";
      const fallbackOpts =
        Array.isArray(cfg.fallback_opts) && cfg.fallback_opts.length >= 2
          ? cfg.fallback_opts.slice(0, 6).map(String)
          : ["3", "4", "5"];
      const fallbackCorrectIdx =
        Number.isInteger(cfg.fallback_correct) ? cfg.fallback_correct : 1;

      // 3) construir pack
      let pack = [];
      if (base && Array.isArray(base.questions) && base.questions.length) {
        pack = base.questions.slice();
      } else if (base) {
        pack = [base];
      } else {
        pack = [{
          q: fallbackPrompt,
          options: fallbackOpts,
          correct: fallbackCorrectIdx
        }];
      }

      let idx = 0;

      function showCurrent() {
        const q = pack[idx] || {};
        let prompt = fallbackPrompt;
        let options = fallbackOpts.slice();
        let correctIdx = fallbackCorrectIdx;

        const txt = q.q ?? q.question ?? q.pregunta;
        if (typeof txt === "string" && txt.trim()) prompt = txt.trim();

        if (Array.isArray(q.options)) options = q.options.slice();
        else if (Array.isArray(q.opts)) options = q.opts.slice();
        else if (Array.isArray(q.alternativas)) options = q.alternativas.slice();
        else {
          const alts = [q.a1, q.a2, q.a3, q.a4, q.a5, q.a6]
            .filter(v => typeof v === "string" && v.trim());
          if (alts.length) options = alts;
        }

        options = options.map(String).filter(Boolean).slice(0, 6);
        if (options.length < 2) options = ["Opción 1", "Opción 2"];

        if (Number.isInteger(q.correct)) correctIdx = Number(q.correct);
        else if (Number.isInteger(q.ans)) correctIdx = Number(q.ans) - 1;
        else if (Number.isInteger(q.answer)) correctIdx = Number(q.answer) - 1;
        else if (typeof q.correctText === "string") {
          const pos = options.findIndex(o => o === q.correctText);
          if (pos >= 0) correctIdx = pos;
        }

        if (!(correctIdx >= 0 && correctIdx < options.length)) {
          const maybe1 = Number(q.correct);
          correctIdx =
            (Number.isFinite(maybe1) &&
              maybe1 >= 1 &&
              maybe1 <= options.length)
              ? (maybe1 - 1)
              : 0;
        }

        const label =
          pack.length > 1 ? `[${idx + 1}/${pack.length}] ${prompt}` : prompt;

        ASK.open(label, options, correctIdx, handleOk, handleBad);
      }

      function handleOk() {
        if (idx < pack.length - 1) {
          // siguiente pregunta del mismo enemigo
          idx += 1;
          showCurrent();
        } else {
          // última pregunta -> se cierra y elimina al enemigo
          ASK.close();
          if (typeof onEnemyOk === "function") onEnemyOk();
        }
      }

      function handleBad() {
        // error -> solo feedback al motor; la pregunta queda abierta
        if (typeof onEnemyBad === "function") onEnemyBad();
      }

      showCurrent();
    }

  </script>

  <!-- ================== CONTROLES MÓVILES ================== -->
  <script>
    (() => {
      const isCoarse = typeof matchMedia === 'function' && matchMedia('(pointer: coarse)').matches;
      const force = new URLSearchParams(location.search).get('touch') === '1';
      if (!(isCoarse || force)) return;

      const pressed = new Set();
      const fire = (type, code, key) => window.dispatchEvent(new KeyboardEvent(type, { code, key, bubbles: true, cancelable: true }));
      const press = (code, key = code) => { if (pressed.has(code)) return; pressed.add(code); fire('keydown', code, key); };
      const release = (code, key = code) => { if (!pressed.has(code)) return; pressed.delete(code); fire('keyup', code, key); };
      const jumpDown = () => { press('Space', ' '); press('ArrowUp', 'ArrowUp'); };
      const jumpUp = () => { release('Space', ' '); release('ArrowUp', 'ArrowUp'); };

      /* ======= ESTILOS (incluye botón de salto) ======= */
      const style = document.createElement('style');
      style.textContent = `
        .mc-wrap{position:fixed;inset:0;pointer-events:none;z-index:12000}
        .mc-joy,.mc-jump{position:absolute;bottom:18px;pointer-events:auto;touch-action:none;user-select:none}
        .mc-joy{left:18px;width:160px;height:160px}
        .mc-joy-base{position:absolute;inset:0;border-radius:50%;
          background:radial-gradient(50% 50% at 50% 50%, rgba(255,255,255,.15), rgba(0,0,0,.25));
          border:1px solid rgba(255,255,255,.25);backdrop-filter:blur(4px)}
        .mc-joy-dead{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:64px;height:64px;border-radius:50%;
          background:rgba(255,255,255,.08);border:1px dashed rgba(255,255,255,.18)}
        .mc-joy-knob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:80px;height:80px;border-radius:50%;
          background:rgba(255,255,255,.25);border:1px solid rgba(255,255,255,.35);box-shadow:0 4px 18px rgba(0,0,0,.35)}

        /* --- Botón SALTAR estilo de la imagen --- */
        .mc-jump{right:18px;width:clamp(60px,12.5vmin,90px);height:clamp(60px,12.5vmin,90px)}
        .mc-jump-btn{
          width:100%;height:100%;border:none;border-radius:50%;position:relative;cursor:pointer;outline:none;
          background:
            radial-gradient(65% 65% at 50% 45%, rgba(255,255,255,.05), rgba(255,255,255,0) 70%),
            radial-gradient(100% 100% at 50% 50%, #0f0f12, #232428);
          box-shadow: 0 8px 26px rgba(0,0,0,.6), inset 0 0 0 2px rgba(255,255,255,.05);
        }
        /* anillo negro interno */
        .mc-jump-btn::before{
          content:""; position:absolute; inset:9%; border-radius:50%;
          box-shadow: inset 0 0 0 2px rgba(0,0,0,.65), inset 0 6px 12px rgba(0,0,0,.6);
        }
        /* anillo dorado */
        .mc-jump-btn::after{
          content:""; position:absolute; inset:-2px; border-radius:50%;
          border:2px solid rgba(219,171,56,.65);
          box-shadow: 0 0 10px rgba(219,171,56,.35), inset 0 0 10px rgba(219,171,56,.18);
          pointer-events:none;
        }
        .mc-jump-btn:active{ transform:scale(.96) }

        /* flecha blanca centrada */
        .mc-jump-ico{position:absolute;inset:0;display:grid;place-items:center;filter:drop-shadow(0 2px 2px rgba(0,0,0,.6))}
        .mc-jump-ico svg{ width:48%; height:48%; }
        .mc-jump-ico path{ fill:#fff; }

        @media (orientation:landscape){
          .mc-joy{bottom:14px;left:14px;width:150px;height:150px}
          .mc-jump{bottom:14px;right:14px;width:clamp(56px,11vmin,84px);height:clamp(56px,11vmin,84px)}
        }
        .force-touch .mc-wrap{display:block}
      `;
      document.head.appendChild(style);

      /* ======= DOM ======= */
      const wrap = document.createElement('div');
      wrap.className = 'mc-wrap';
      wrap.innerHTML = `
        <div class="mc-joy" aria-label="Joystick">
          <div class="mc-joy-base"></div>
          <div class="mc-joy-dead"></div>
          <div class="mc-joy-knob"></div>
        </div>
        <div class="mc-jump">
          <button class="mc-jump-btn" type="button" aria-label="Saltar" title="Saltar">
            <span class="mc-jump-ico">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 3l5.2 5.2-1.4 1.4L13 6.8V20h-2V6.8L8.2 9.6 6.8 8.2 12 3z"/>
              </svg>
            </span>
          </button>
        </div>`;
      document.body.appendChild(wrap);
      if (force) document.body.classList.add('force-touch');

      /* ======= Joystick ======= */
      const joy = wrap.querySelector('.mc-joy'), knob = wrap.querySelector('.mc-joy-knob');
      const R = 74, DEAD = 20, HYST = 6; let origin = null, active = false, lastDir = 0, lastTap = 0;

      const setDir = (dir) => {
        if (dir === lastDir) return;
        if (lastDir === -1) release('ArrowLeft', 'ArrowLeft');
        if (lastDir === +1) release('ArrowRight', 'ArrowRight');
        if (dir === -1) press('ArrowLeft', 'ArrowLeft');
        if (dir === +1) press('ArrowRight', 'ArrowRight');
        lastDir = dir;
      };
      const updateKnob = (vx, vy) => {
        const mag = Math.hypot(vx, vy); let dir = 0;
        if (mag > DEAD + HYST) { if (vx < -DEAD) dir = -1; else if (vx > DEAD) dir = +1; }
        else if (mag < DEAD - HYST) { dir = 0; } else { dir = lastDir; }
        setDir(dir);
        const clampMag = Math.min(R, mag);
        const nx = (mag ? (vx / mag) : 0) * clampMag, ny = (mag ? (vy / mag) : 0) * clampMag;
        knob.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
      };
      const joyStart = (x, y) => {
        active = true; const rect = joy.getBoundingClientRect();
        origin = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        updateKnob(0, 0);
        const t = performance.now(); if (t - lastTap < 280) { jumpDown(); setTimeout(jumpUp, 120); } lastTap = t;
      };
      const joyMove = (x, y) => { if (!active) return; updateKnob(x - origin.x, y - origin.y); };
      const joyEnd = () => { if (!active) return; active = false; setDir(0); knob.style.transform = 'translate(-50%,-50%)'; };
      joy.addEventListener('pointerdown', e => { e.preventDefault(); joy.setPointerCapture(e.pointerId); joyStart(e.clientX, e.clientY); });
      joy.addEventListener('pointermove', e => { if (!active) return; e.preventDefault(); joyMove(e.clientX, e.clientY); });
      ['pointerup', 'pointercancel', 'pointerleave'].forEach(ev => joy.addEventListener(ev, e => { e.preventDefault(); joyEnd(); }));

      /* ======= Salto ======= */
      const btnJump = wrap.querySelector('.mc-jump-btn');
      btnJump.addEventListener('pointerdown', e => { e.preventDefault(); jumpDown(); });
      const endJump = e => { e && e.preventDefault(); jumpUp(); };
      btnJump.addEventListener('pointerup', endJump); btnJump.addEventListener('pointercancel', endJump); btnJump.addEventListener('pointerleave', endJump);

      /* Swipe-up rápido = salto */
      let swipeStart = null;
      window.addEventListener('touchstart', e => { const t = e.changedTouches[0]; swipeStart = { x: t.clientX, y: t.clientY, time: performance.now() }; }, { passive: true });
      window.addEventListener('touchend', e => {
        if (!swipeStart) return; const t = e.changedTouches[0];
        const dx = t.clientX - swipeStart.x, dy = t.clientY - swipeStart.y, dt = performance.now() - swipeStart.time;
        if (dt < 280 && dy < -42 && Math.abs(dx) < 70) { jumpDown(); setTimeout(jumpUp, 120); }
        swipeStart = null;
      }, { passive: true });

      /* Ocultar si aparece teclado físico */
      let hidden = false; function hideUI() {
        if (hidden) return; document.querySelector('.mc-wrap').style.display = 'none'; hidden = true;
        window.addEventListener('touchstart', () => { document.querySelector('.mc-wrap').style.display = ''; hidden = false; }, { once: true, passive: true });
      }
      window.addEventListener('keydown', hideUI, { once: true });
    })();
  </script>
</body>

</html>